// Четвертая лаба
// взаимодействовать потоки могут по памяти, по ресурсам, за процессорное время
// 1. правило, подготовиться к входу в критическую секцию, быстро войти, быстро выйти 
// организовать критическую секцию, войти, выйти, закрыть шлагбаум
// одномоментно захватывать критический ресурс
// test inset
// тупик - забыли поднять шлагбаум или вошли и не можем сделать или неправильный захват ресурса
// посмотрели интерлокд, инкремент, эксчендж, атомарные типы
// Пятая лаба
// особенности работы с критической секцией - заставляют ждать в активном режиме
// если без конца спрашивать шлагбаум, процессор не сможет поднять его
// Sleep(0) - изменение на ожидание, а значит пауза
// ОС винда, чтобы мы не нарушили ничего, есть режим пользователя, режим ядра ОС
// интерлокд и атомик - пользовательские, сегодняшние - в режиме ядра
// они могут посредством ядра переводить потоки между акт/ожид, создавать процессы
// мы тоже будем работать а-ля ОС, будить потоки
// condition erable
// Пятая лаба в двух потоках, распараллеливание по данным
// 
// данные разделили поровну, каждый поток один раз выполняет задачу потока, а мы ждем все потоки
// а теперь потоки будут работать в циклах, каждый поток берёт маленькую порцию, быстро их обрабатывают и берут следующую
// цель - создать пул потоков
// сообщаем границы участков, потоков 3 дочерних + main
// любой контейнер для пула, снаружи обёртка, с контейнером работает мэйн
// желательно стек или очередь
// потоки должны работать в атомарном режиме
// thread_safe_queue TSQ
// цикл работы каждого потока - пока в пуле есть задачи
// объект должен быть мощнее, кому-то критическая секция
// только метод call безопасный
// нужно сделать атомарными front и pop
// 
// знать, как конструируется, деструктурируется, как заходить и как выходить
// 
// на экзе будет алгоритм с возвратом, надо перебрать набор вариантов.
// 
// в 6 лабе безопасный даже push
// 
// продолжили 
// критическая секция есть на языковом уровне
// критическую секцию нужно где-то описать, чтобы войти в неё, нужно выполнить операцию, спин-блокировка
// выполняем задачу с глобальным ресурсом, выходим, используем ту же операцию интре что-то
// в деструкторе должна быть эта операция, 
// мы описываем так, как красным в конспекте написано
// достаточно в private зоне описать объект
// момент обязательный: выход обязан осуществляться (не важно аварийно/нет), мы не создаём смертельную петлю
// 1 вариант - создать исключения
// с++ создал обертки lock_guard (не WinAPI, а для него), в неё мы оборачиваем другую обертку,
// когда мы её создаем, появляется lock() (красненький)
// при выходе вызывается деструктор, а в нём unlock(), он может сработать автоматически
// 
// три объекта ядра: события, семафоры, мьютексы. Сначла создать Create, потом закрыть Close
// ждём wait-функциями, на самом деле возвращает результат, - истёк объект, не перешел в свободное состояние
// - возвращает сообщение от завершившегося / ладно, пофиг
// 
// события:
// посомтрели сигнатуру, я не успеваю за ней писать
// описать объект ядра, 
// 
// семафор может быть не только 0/1, бинарный или общего назначения
// особенно для задач с несколькими разделяемыми ресурсами
// 
// мьютексы
// можно узнать, возникли ли у него шоибки
// один мьютексы для глобального, другой для очереди
// lock_guard - не нужно руками освобождать
// unique_lock - можно
// 
// если надо, использкем std::move
// 
// шестая задача
// модель: 4 основные проблемы, разные модели работы с крит.ресами
// производители-потребители
// читатели-писатели
// барабанные палочки+барабан
// спящий парикмахер
// 
// теперь несколько потоков производителей, несколько потребителей
// продюсеры - задача - создать массив из 110 элементов
// TSQ, каждый ждёт очередь положить в очередь, кладёт и начинает заново
// консьюмеры - если есть массив в очереди, забирает, считает сумму, если нет, то не завершается
// будет потокобезопасный пуш
// на наше усмотрение - цикл, сколько итераций они должны работать
// v_P и v_С - объёмы работы
// while ( есть работа )
// 
//

#include <iostream>
#include <Windows.h>
#include <mutex>
#include <queue>
#include <thread>

int COUNT = 25;
const int NUM_THREAD = 4;

struct Pair {
    size_t left, right;
};

class ThreadSafeQueue {
private:
    std::mutex mutex;
    std::queue<Pair> queue;
public:
    ThreadSafeQueue() {};
    void push(Pair elem) {
        queue.push(elem);
    }
    bool try_pop(Pair& elem) {
        bool result{ false };
        if (!queue.empty()) {// зачем стоять в очереди, если заведомо хуже
            // пока стояли в очереди глобал мог измениться
            // у меня будет try_catch 
            std::lock_guard<std::mutex> locker(mutex);
            if (!queue.empty()) {
                result = true;
                elem = queue.front();
                queue.pop();
            }
        }
        return result;
    };
    bool empty() {
        return queue.empty();
    }
};

ThreadSafeQueue TSQ;

std::mutex mutex_task;

void sum(int* arr, long volatile& global_sum) {
    Pair pair{};
    while (TSQ.try_pop(pair)) {
        long local_sum{};
        for (size_t i{ pair.left }; i < pair.right; ++i) {
            local_sum += arr[i];
            std::this_thread::sleep_for(std::chrono::milliseconds(1));

        }
        std::lock_guard<std::mutex> locker(mutex_task);
        global_sum += local_sum;
    }
}

int sum_parallel(int* arr) {
    size_t chunk{ 10 };
    size_t left{}, right{};
    while (right != COUNT) {
        left = right;
        right = right + chunk < COUNT ? right + chunk : COUNT;
        TSQ.push(Pair{ left, right });
    }

    std::thread thr[NUM_THREAD - 1];
    long volatile global_sum{};
    for (size_t i{}; i < NUM_THREAD - 1; ++i) {
        thr[i] = std::thread(sum, arr, std::ref(global_sum));
    }

    sum(arr, global_sum);

    for (int i{}; i < NUM_THREAD - 1; ++i)
        thr[i].join();

    return global_sum;
}

int sum_non_paral(int* arr) {
    int result{};
    for (int i{}; i < COUNT; ++i)
        result += arr[i];
    return result;
}

void fill(int* arr) {
    srand(GetTickCount());
    for (int i{}; i < COUNT; ++i)
        arr[i] = rand() % 100;
}
void print(int* arr) {
    for (int i{}; i < COUNT; ++i)
        std::cout << arr[i] << ' ';
    std::cout << '\n';
}

int main()
{
    int* arr = new int[COUNT];

    fill(arr);
    std::cout << "Array: ";
    print(arr);

    std::cout << "Non parallel sum: " << sum_non_paral(arr) << '\n';
    std::cout << "Parallel sum:     " << sum_parallel(arr) << '\n';

    return 0;
}